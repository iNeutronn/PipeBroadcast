// <auto-generated>
using System.Reflection;

namespace FxResources.System.IO.Pipes
{
    internal static class SR { }
}
namespace NativePipes
{
    internal static partial class SR
    {
        private static global::System.Resources.ResourceManager s_resourceManager;
        internal static global::System.Resources.ResourceManager ResourceManager => s_resourceManager ?? (s_resourceManager = new global::System.Resources.ResourceManager(typeof(FxResources.System.IO.Pipes.SR)));

        /// <summary>Non-negative number required.</summary>
        internal static string @ArgumentOutOfRange_NeedNonNegNum => GetResourceString("ArgumentOutOfRange_NeedNonNegNum");
        /// <summary>Invalid PipeAccessRights value.</summary>
        internal static string @ArgumentOutOfRange_NeedValidPipeAccessRights => GetResourceString("ArgumentOutOfRange_NeedValidPipeAccessRights");
        /// <summary>This flag may not be set on a pipe.</summary>
        internal static string @Argument_NonContainerInvalidAnyFlag => GetResourceString("Argument_NonContainerInvalidAnyFlag");
        /// <summary>serverName cannot be an empty string.  Use \\\".\\\" for current machine.</summary>
        internal static string @Argument_EmptyServerName => GetResourceString("Argument_EmptyServerName");
        /// <summary>Handle has been disposed or is invalid.</summary>
        internal static string @Argument_InvalidHandle => GetResourceString("Argument_InvalidHandle");
        /// <summary>serverName cannot be null. Use \".\" for current machine.</summary>
        internal static string @ArgumentNull_ServerName => GetResourceString("ArgumentNull_ServerName");
        /// <summary>The pipeName \"anonymous\" is reserved.</summary>
        internal static string @ArgumentOutOfRange_AnonymousReserved => GetResourceString("ArgumentOutOfRange_AnonymousReserved");
        /// <summary>For named pipes, transmission mode can be TransmissionMode.Byte or PipeTransmissionMode.Message. For anonymous pipes, transmission mode can be TransmissionMode.Byte.</summary>
        internal static string @ArgumentOutOfRange_TransmissionModeByteOrMsg => GetResourceString("ArgumentOutOfRange_TransmissionModeByteOrMsg");
        /// <summary>For named pipes, the pipe direction can be PipeDirection.In, PipeDirection.Out or PipeDirection.InOut. For anonymous pipes, the pipe direction can be PipeDirection.In or PipeDirection.Out.</summary>
        internal static string @ArgumentOutOfRange_DirectionModeInOutOrInOut => GetResourceString("ArgumentOutOfRange_DirectionModeInOutOrInOut");
        /// <summary>TokenImpersonationLevel.None, TokenImpersonationLevel.Anonymous, TokenImpersonationLevel.Identification, TokenImpersonationLevel.Impersonation or TokenImpersonationLevel.Delegation required.</summary>
        internal static string @ArgumentOutOfRange_ImpersonationInvalid => GetResourceString("ArgumentOutOfRange_ImpersonationInvalid");
        /// <summary>options contains an invalid flag.</summary>
        internal static string @ArgumentOutOfRange_OptionsInvalid => GetResourceString("ArgumentOutOfRange_OptionsInvalid");
        /// <summary>HandleInheritability.None or HandleInheritability.Inheritable required.</summary>
        internal static string @ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable => GetResourceString("ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable");
        /// <summary>Timeout must be non-negative or equal to -1 (Timeout.Infinite)</summary>
        internal static string @ArgumentOutOfRange_InvalidTimeout => GetResourceString("ArgumentOutOfRange_InvalidTimeout");
        /// <summary>maxNumberOfServerInstances must either be a value between 1 and 254, or NamedPipeServerStream.MaxAllowedServerInstances (to obtain the maximum number allowed by system resources).</summary>
        internal static string @ArgumentOutOfRange_MaxNumServerInstances => GetResourceString("ArgumentOutOfRange_MaxNumServerInstances");
        /// <summary>Positive number required.</summary>
        internal static string @ArgumentOutOfRange_NeedPosNum => GetResourceString("ArgumentOutOfRange_NeedPosNum");
        /// <summary>Pipe hasn't been connected yet.</summary>
        internal static string @InvalidOperation_PipeNotYetConnected => GetResourceString("InvalidOperation_PipeNotYetConnected");
        /// <summary>Pipe is in a disconnected state.</summary>
        internal static string @InvalidOperation_PipeDisconnected => GetResourceString("InvalidOperation_PipeDisconnected");
        /// <summary>Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?</summary>
        internal static string @InvalidOperation_PipeHandleNotSet => GetResourceString("InvalidOperation_PipeHandleNotSet");
        /// <summary>ReadMode is not of PipeTransmissionMode.Message.</summary>
        internal static string @InvalidOperation_PipeReadModeNotMessage => GetResourceString("InvalidOperation_PipeReadModeNotMessage");
        /// <summary>Already in a connected state.</summary>
        internal static string @InvalidOperation_PipeAlreadyConnected => GetResourceString("InvalidOperation_PipeAlreadyConnected");
        /// <summary>Already in a disconnected state.</summary>
        internal static string @InvalidOperation_PipeAlreadyDisconnected => GetResourceString("InvalidOperation_PipeAlreadyDisconnected");
        /// <summary>Unable to read beyond the end of the stream.</summary>
        internal static string @IO_EOF_ReadBeyondEOF => GetResourceString("IO_EOF_ReadBeyondEOF");
        /// <summary>Unable to find the specified file.</summary>
        internal static string @IO_FileNotFound => GetResourceString("IO_FileNotFound");
        /// <summary>Could not find file '{0}'.</summary>
        internal static string @IO_FileNotFound_FileName => GetResourceString("IO_FileNotFound_FileName");
        /// <summary>Cannot create '{0}' because a file or directory with the same name already exists.</summary>
        internal static string @IO_AlreadyExists_Name => GetResourceString("IO_AlreadyExists_Name");
        /// <summary>The file '{0}' already exists.</summary>
        internal static string @IO_FileExists_Name => GetResourceString("IO_FileExists_Name");
        /// <summary>Pipe is broken.</summary>
        internal static string @IO_IO_PipeBroken => GetResourceString("IO_IO_PipeBroken");
        /// <summary>IO operation was aborted unexpectedly.</summary>
        internal static string @IO_OperationAborted_Unexpected => GetResourceString("IO_OperationAborted_Unexpected");
        /// <summary>The process cannot access the file '{0}' because it is being used by another process.</summary>
        internal static string @IO_SharingViolation_File => GetResourceString("IO_SharingViolation_File");
        /// <summary>The process cannot access the file because it is being used by another process.</summary>
        internal static string @IO_SharingViolation_NoFileName => GetResourceString("IO_SharingViolation_NoFileName");
        /// <summary>Pipe is broken.</summary>
        internal static string @IO_PipeBroken => GetResourceString("IO_PipeBroken");
        /// <summary>Invalid pipe handle.</summary>
        internal static string @IO_InvalidPipeHandle => GetResourceString("IO_InvalidPipeHandle");
        /// <summary>Could not find a part of the path '{0}'.</summary>
        internal static string @IO_PathNotFound_Path => GetResourceString("IO_PathNotFound_Path");
        /// <summary>Could not find a part of the path.</summary>
        internal static string @IO_PathNotFound_NoPathName => GetResourceString("IO_PathNotFound_NoPathName");
        /// <summary>The specified file name or path is too long, or a component of the specified path is too long.</summary>
        internal static string @IO_PathTooLong => GetResourceString("IO_PathTooLong");
        /// <summary>Stream does not support reading.</summary>
        internal static string @NotSupported_UnreadableStream => GetResourceString("NotSupported_UnreadableStream");
        /// <summary>Stream does not support seeking.</summary>
        internal static string @NotSupported_UnseekableStream => GetResourceString("NotSupported_UnseekableStream");
        /// <summary>Stream does not support writing.</summary>
        internal static string @NotSupported_UnwritableStream => GetResourceString("NotSupported_UnwritableStream");
        /// <summary>Anonymous pipes can only be in one direction.</summary>
        internal static string @NotSupported_AnonymousPipeUnidirectional => GetResourceString("NotSupported_AnonymousPipeUnidirectional");
        /// <summary>Anonymous pipes do not support PipeTransmissionMode.Message ReadMode.</summary>
        internal static string @NotSupported_AnonymousPipeMessagesNotSupported => GetResourceString("NotSupported_AnonymousPipeMessagesNotSupported");
        /// <summary>Cannot access a closed pipe.</summary>
        internal static string @ObjectDisposed_PipeClosed => GetResourceString("ObjectDisposed_PipeClosed");
        /// <summary>Access to the path '{0}' is denied.</summary>
        internal static string @UnauthorizedAccess_IODenied_Path => GetResourceString("UnauthorizedAccess_IODenied_Path");
        /// <summary>Access to the path is denied.</summary>
        internal static string @UnauthorizedAccess_IODenied_NoPathName => GetResourceString("UnauthorizedAccess_IODenied_NoPathName");
        /// <summary>Specified file length was too large for the file system.</summary>
        internal static string @ArgumentOutOfRange_FileLengthTooBig => GetResourceString("ArgumentOutOfRange_FileLengthTooBig");
        /// <summary>Message transmission mode is not supported on this platform.</summary>
        internal static string @PlatformNotSupported_MessageTransmissionMode => GetResourceString("PlatformNotSupported_MessageTransmissionMode");
        /// <summary>Access to remote named pipes is not supported on this platform.</summary>
        internal static string @PlatformNotSupported_RemotePipes => GetResourceString("PlatformNotSupported_RemotePipes");
        /// <summary>The name of a pipe on this platform must be a valid file name or a valid absolute path to a file name.</summary>
        internal static string @PlatformNotSupported_InvalidPipeNameChars => GetResourceString("PlatformNotSupported_InvalidPipeNameChars");
        /// <summary>Cannot access a closed stream.</summary>
        internal static string @ObjectDisposed_StreamClosed => GetResourceString("ObjectDisposed_StreamClosed");
        /// <summary>The operating system returned error '{0}' indicating that the operation is not supported.</summary>
        internal static string @PlatformNotSupported_OperatingSystemError => GetResourceString("PlatformNotSupported_OperatingSystemError");
        /// <summary>All pipe instances are busy.</summary>
        internal static string @IO_AllPipeInstancesAreBusy => GetResourceString("IO_AllPipeInstancesAreBusy");
        /// <summary>The path '{0}' is too long, or a component of the specified path is too long.</summary>
        internal static string @IO_PathTooLong_Path => GetResourceString("IO_PathTooLong_Path");
        /// <summary>Could not connect to the pipe because it was not owned by the current user.</summary>
        internal static string @UnauthorizedAccess_NotOwnedByCurrentUser => GetResourceString("UnauthorizedAccess_NotOwnedByCurrentUser");
        /// <summary>Client connection (user id {0}) was refused because it was not owned by the current user (id {1}).</summary>
        internal static string @UnauthorizedAccess_ClientIsNotCurrentUser => GetResourceString("UnauthorizedAccess_ClientIsNotCurrentUser");
        /// <summary>'pipeSecurity' must be null when 'options' contains 'PipeOptions.CurrentUserOnly'.</summary>
        internal static string @NotSupported_PipeSecurityIsCurrentUserOnly => GetResourceString("NotSupported_PipeSecurityIsCurrentUserOnly");
        /// <summary>System.IO.Pipes is not supported on this platform.</summary>
        internal static string @Pipes_PlatformNotSupported => GetResourceString("Pipes_PlatformNotSupported");

    }
}
